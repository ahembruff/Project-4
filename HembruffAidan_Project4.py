# -*- coding: utf-8 -*-
"""
Created on Mon Nov 25 13:57:24 2024

@author: aidan
"""

# Project 4

import numpy as np
from numpy.linalg import eig
from numpy.linalg import inv
import cmath

def spectral_radius(A):
    '''
    Author : Aidan Hembruff
    
    A function which finds the eigenvalue with the maximum
    absolute value for a 2-D array

    Parameters
    ----------
    A : The input 2-dimensional matrix

    Returns
    -------
    The eigenvalue of the matrix with the maximum absolute value

    '''
    eigenvalues = eig(A)[0] # eigenvalues of A
    return np.max(np.abs(eigenvalues)) # maximum absolute eigenvalue

def make_tridiagonal(N,b,d,a):
    '''
    A function which takes numerical inputs to generate an NxN
    tridiagnonal matrix with specified values

    Parameters
    ----------
    N : The length of the array's rows and columns
    
    b : The value which will go on the lower diagonal
    
    d : The value which will go on the main diagonal
    
    a : The value which will go on the upper diagonal

    Returns
    -------
    The tridiagonal matrix generated by the input values

    '''
    # create the tridiagonal matrix by summing matrices with the specified values,
    # on the lower, main, and upper diagonals
    return d*np.identity(N)+(b*np.eye(N,k=-1))+(a*np.eye(N,k=1)) 

def make_initialcond(xi,k0,sigma0):
    '''
    Author : Aidan Hembruff
    
    A function which returns the initial wavepacket of a given form
    based on scalable input parameters and grid
    
    Parameters
    ----------
    xi : The spatial grid which the wavepacket will be a function of
    
    k0 : Scalable parameter for the wavepacket
    
    sigma0 : Scalable parameter for the wavepacket

    Returns
    -------
    The wavepacket function determined by the parameters and spatial grid

    '''
    return (np.exp((-(xi**2))/(2*(sigma0**2))))*np.cos(k0*xi) # wavepacket function

def sch_eqn(nspace,ntime,tau,method="ftcs",length=200,potential=[],wparam=[10,0,0.5]):
    
    sigma0 , x0, k0 =  wparam[0], wparam[1], wparam[2] 
    h = length/(nspace-1)
    
    hbar = 1
    mass = 0.5
    ftcs_coeff = 1j*tau/hbar 
    
    crank_coeff = 1j*tau/(2*hbar)
    
    H_coeff = -hbar**2/(2*mass*h)
    
    H = H_coeff*make_tridiagonal(nspace,1,-2,1)
    
    # Periodic BCs from Textbook
    H[0,-1] = H_coeff ; H[0,0] = -2*H_coeff ; H[0,1] = H_coeff
    H[-1,2] = H_coeff ; H[-1,-1] = -2*H_coeff ; H[-1,0] = H_coeff
    
    for i in potential:
        H[i,i] += 1  
    
    x = np.linspace(-length/2,length/2,nspace)
    t = tau*np.arange(0,ntime) # the time grid
    
    if method == "ftcs":
        
        probability = np.zeros((ntime))
        
        # below from Lab 11
        psi = np.zeros((nspace,ntime)) # initialize the array for storing the complete spatial solution
        
        # initial condition using make_initialcond function developed in Lab 10
        psi[:+x0,0] = make_initialcond(x,k0,sigma0)
        
        ftcs_A = np.identity(nspace) - ftcs_coeff*H
        
        # following 7 lines adapted from Lab 11
        # iterate over the number of time steps to obtain spatial solutions for every time step
        for istep in range(1, ntime):
            psi[:,istep] = ftcs_A.dot(psi[:,istep-1])
            
            probability[istep] = psi[:,istep]**2
        
        # Solution stability is determined by maximum valued eigenvalue of A
        # spectral_radius function is from Lab 10
        stability = spectral_radius(ftcs_A)
        
        # print statement for solution stability
        if stability <= 1:
            print("Solution is expected to be stable")
        else:
            print("Warning! Solution is expected to be unstable")
            
    if method == "crank":
        
        probability = np.zeros((ntime))
        
        psi = np.zeros((nspace,ntime))
        
        # initial condition using make_initialcond function developed in Lab 10
        psi[:+x0,0] = make_initialcond(x,k0,sigma0)
        
        crank_A = inv(np.identity(nspace)+crank_coeff*H).dot(np.identity(nspace)-crank_coeff*H)
        
        # following 7 lines adapted from Lab 11
        # iterate over the number of time steps to obtain spatial solutions for every time step
        for istep in range(1, ntime):
            psi[:,istep] = crank_A.dot(psi[:,istep-1])
            
            probability[istep] = psi[:,istep]**2
    
    return psi, x, t

def sch_plot(plot_type="psi",save=True):
    
    return